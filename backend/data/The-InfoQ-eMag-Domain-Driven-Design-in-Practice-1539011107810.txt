FACILITATING THE SPREAD OF KNOWLEDGE AND INNOVATION IN PROFESSIONAL SOFTWARE DEVELOPMENT
DOMAIN
DRIVEN
DESIGN
in PRACTICE
eMag Issue 65 - Oct 2018
    INTERVIEW
DDD with TLC - Q&A with Julie Lerman
ARTICLE
Refactoring to a Deeper Model
ARTICLE
Modeling Uncertainty with Reactive DDD
   
IN THIS ISSUE
6
10
14 20
28
  DDD with TLC - Q&A with Julie Lerman
At the 2017 Explore DDD conference, Julie Lerman, a self-described Serial DDD Ad- vocate, spoke about how to approach Domain-Driven Design with Tender Loving Care. InfoQ sat down with Lerman to ask about how she introduces DDD to new clients, and helps them be successful.
The DDD Do-Over - Q&A with Jimmy Bogard
Jimmy Bogard had a rare opportunity to do what many developers want after finishing a tough project -- a do-over. His team worked on two very similar projects, both using DDD. He discusses the lessons learned from the first project and how the team avoided common pitfalls and was more successful on their later project.
Virtual Panel: Succeeding with Event Sourcing
Why should you use event sourcing as a data storage and retrieval technique? What are the architectural implications? When should you use platforms versus frameworks to satisfy requirements? InfoQ interviewed two experts to learn more.
Refactoring to a Deeper Model
Paul Rayner uses a case study to demonstrate how refactoring your code can lead to a deeper understanding of your domain model. Through common code refac- torings, combined with the implementation of patterns, the codebase became more cohesive and easier to reason about, reducing the time to perform some common tasks from weeks or months to just hours.
Modeling Uncertainty with Reactive DDD
Vaughn Vernon has written several books on DDD and reactive messaging pat- terns, and has found that the nature of distributed systems means you must deal with uncertainty. How to respond to a missing message, or a message that is received twice, should be a business decision, and therefore must be part of the domain model.
     FOLLOW US
facebook.com @InfoQ /InfoQ
CONTACT US
GENERAL FEEDBACK feedback@infoq.com ADVERTISING sales@infoq.com EDITORIAL editors@infoq.com
       google.com /+InfoQ
linkedin.com company/infoq

A LETTER FROM THE EDITOR
 Domain-Driven Design has been around for 15 years, but the level of interest in DDD has been rising significantly in the past few years. Some credit this with the rise in microservice architec- ture, cloud computing, and distributed systems, all of which can benefit from DDD concepts such as bounded contexts. Based on the continued popularity of the InfoQ mini-book, Domain-Driv- en Design Quickly, many developers and archi- tects want to learn about DDD and start applying it to their projects.
This eMag highlights some of the experience of real-world DDD practitioners, including the chal- lenges they have faced, missteps they�ve made, lessons learned, and some success stories.
Julie Lerman is an author, speaker, and expert consultant often brought in on projects that are looking at adopting DDD, and need some coach- ing to get started on the right path. We asked her about how she uses a gentle approach to gradu- ally introduce DDD with small concepts, and get past the common concern that DDD is too great a change from existing processes and team cul- ture.
Jimmy Bogard had a rare opportunity to do what many developers want after finishing a tough project -- a do-over. His team worked on two very similar projects, both using DDD. He discusses
the lessons learned from the first project and how the team avoided common pitfalls and was more successful on their later project. If you�re starting your first DDD project, you�ll appreciate learning the same lessons from someone else�s experience.
While Event Sourcing isn�t truly a concept dis- cussed in DDD, it is a method for storing state that aligns well with a message-driven system that communicates via domain events. The vir- tual panel, Succeeding with Event Sourcing, in- cludes insights from Ben Wilcock and Allard Bui- jze on using event sourcing on real applications.
Paul Rayner uses a case study to demonstrate how refactoring your code can lead to a deeper understanding of your domain model. Through common code refactorings, combined with the implementation of patterns, the codebase be- came more cohesive and easier to reason about, reducing the time to perform some common tasks from weeks or months to just hours.
Vaughn Vernon has written several books on DDD and reactive messaging patterns, and has found that the nature of distributed systems means you must deal with uncertainty. How to respond to a missing message, or a message that is received twice, should be a business decision, and therefore must be part of the domain model.
Thomas Betts

CONTRIBUTORS
 Thomas Betts
is a Principal Software Engineer at IHS Markit, with two decades of professional software development experience. His focus has always been on providing software solutions that delight his customers. He has worked in a variety of industries, including retail, finance, health care, defense and travel. Thomas lives in Denver with his wife and son, and they love hiking and otherwise exploring beautiful Colorado.
   Paul Rayner
is a developer, coach, mentor, trainer, and popular international conference speaker. With over 25 years of hands-on software development experience in a variety of industries, Rayner is a seasoned software design coach and leadership mentor, helping teams ignite their design skills. His consulting company Virtual Genius LLC provides training and coaching in software design for agile teams. Rayner is from Perth, Australia, but lives, works and plays in Denver, Colorado, with his wife and two children. He tweets with an Australian accent at @ThePaulRayner and blogs at thepaulrayner.com.
Richard Seroter
is a Senior Director of Product at Pivotal, with a master�s degree in Engineering from the University of Colorado. He�s also a 10-time Microsoft MVP, trainer for developer-centric training company Pluralsight, speaker, the lead InfoQ editor for cloud computing, and author of multiple books on application integration strategies. Richard maintains a regularly updated blog on topics of architecture and solution design and can be found on Twitter as @rseroter
Vaughn Vernon
is a software developer and architect with 35 years of experience in a
broad range of business domains. Vaughn is a leading expert in Domain- Driven Design, and a champion of simplicity and reactive systems. He is the founder and lead architect and developer of the vlingo/platform, and open source DDD-friendly reactive toolkit. He consults and teaches around DDD and reactive software development, helping teams and organizations realize the potential of business driven and reactive systems as they transition from technology driven legacy web implementation approaches, placing strong emphasis on embracing simplicity.
  
 
           Read online on InfoQ
DDD WITH TLC
Q&A WITH JULIE LERMAN
by Thomas Betts
At the 2017 Explore DDD conference, Julie Lerman, a self- described Serial DDD Advocate, spoke about how to approach Domain-Driven Design with Tender Loving Care. InfoQ sat down with Lerman to ask about how she introduces DDD to new clients, and helps them be successful.
 KEY TAKEAWAYS
When introducing DDD to a new team, start with bounded contexts � breaking down big problems into small, manageable, solvable problems. But leave out the terminology and just start doing it.
Understanding the dynamics of a team in order to successfully coach them has a lot to do with instinct and empathy. It�s so important to listen carefully, be respectful, non-judgmental and to be kind.
People resist DDD because they believe it
is too much to learn or is too disruptive to their current process. Solving small problems is a good approach that can gain trust in adopting DDD.
Domain modeling is an art, not a science, so it�s not uncommon to run into a wall and circle back or even have a revelation that makes you change direction. Teams benefit from encountering that with a coach who is familiar with modeling and is not worried about the perspective changing while you are going through the process.
  6 DDD in Practice // eMag Issue 65 - Oct 2018

THE PANELIST
 Julie Lerman
is a Microsoft regional director and a long-time Microsoft MVP. She makes her living as a software coach and consultant to software teams around the world. You
can find Lerman presenting on Entity Framework, Domain-Driven Design and other fun topics at user groups and conferences around the world. Lerman blogs at thedatafarm.com/blog, is the author of the highly acclaimed �Programming Entity Framework� books, the MSDN Magazine Data Points column and popular videos on Pluralsight.com.
  InfoQ: Most DDD practitioners can remember how they
were first introduced to Do- main-Driven Design. What�s your DDD origin story?
Julie Lerman: Mine is thanks to Jimmy Nilsson and believe it or not, InfoQ! Years ago, when Mic- rosoft had released not one, but two ORMs (LINQ to SQL and En- tity Framework) there was a bit of controversy going on. I came across an interview on InfoQ with Jimmy Nilsson where he was asked his opinion on LINQ to SQL and Entity Framework � an opinion I was very interested in. At the end of the interview, Jim- my was asked a question which I guess was asked at the end of all interviews ...�What is your favorite book?� His answer was Eric Evans� Domain-Driven De- sign and Jimmy said that it read like poetry. Poetry! At the time I was writing a book for O�Reil-
ly Press on Entity Framework. It was my first book and I really wanted to know what it meant for a tech book to read like poet- ry. So I picked up the DDD book and the very first discussion was about the importance of engag- ing the domain experts � some- thing that had always been crit- ical to my success with clients. I loved learning about their busi- nesses and have built long-term, strong relationships with many of my clients. So that hooked me in! I thought that I had certainly found someone I could truly re- late to in Eric.
InfoQ: DDD covers a lot of top- ics. When you start working with a new team, how do you introduce DDD for the first time, and how do you avoid overwhelming them with
too many new concepts? Are
there teaching techniques that should be avoided?
Lerman: I�m usually brought in at the point when either they are overhauling or replacing a leg- acy app or well under way. And I�m only there for a short stint, so I try to expose them to as much as I can, as quickly as I can. I start with bounded context � break- ing down their big problems into small, manageable, solvable problems. And I don�t even start with the term. I just start doing it. Then I pick an easy target among the loosely identified bounded contexts and start analyzing it and identifying different parts of the domain model � one at a time, not all at once. And again, I start by using the concepts but not worrying about terminology right away. I know from my own personal experience that my brain locks up when I get the ter- minology thrown at me. So, I find simpler ways to introduce new topics � more obvious analogies. Eventually I add in the actual terms...aggregates, aggregate roots, etc and explain that it�s im- portant to use the terms so that everyone�s on the same page technically. That�s a great segue to ubiquitous language, too!
InfoQ: The subtitle to Evan�s book is �tackling complexity in the heart of software.� Con- way�s law would imply that complex applications often have complex organizations and teams supporting them. Do the concepts of DDD,
such as Bounded Contexts, help with understanding and coaching a team?
Lerman: My approach to under- standing the dynamics of a team in order to successfully coach them has a lot to do with instinct and empathy. It�s so important to listen carefully, be respect-
 DDD in Practice // eMag Issue 65 - Oct 2018 7
 
ful, non-judgmental and to be kind. But I also lean a lot on my instincts and experience to help �read the room,� so to speak. As a Libra, I�m all about balance and mediation. This has helped me a lot with clients when I�m work- ing with teams and need to keep things moving forward, in a pos- itive way. I think this ties back to the human side of the DDD equa- tion � that whole aspect of work- ing closely with your clients to understand their business, iden- tify their problems and gain their trust in you to help solve those problems. This is what originally drew me to Eric�s book. The tech- nical, or tactical design, aspect of DDD was just icing on the cake!
InfoQ: What are some common arguments you hear against adopting DDD? How do you respond to them?
Lerman: Some of the arguments are: Too much to learn. Too dis- ruptive to our process. Will re- quire too much re-thinking, re- factoring, time.
And I draw back to the �solv- ing small problems� approach � looking for opportunities to gain great benefit with a small investment. And it�s a good place to leverage their trust so they will follow along.
InfoQ: If you only have two
or three days to introduce DDD and coach a team, what is your game plan? What are the goals, and how do you optimize the time to get the biggest achievement towards those goals?
Lerman: I first want to know what they are working on, what their goals are and what they are worried about � obvious- ly something, or they wouldn�t
have brought me in. Then I do the magical �let�s break this up into smaller problems�, pick the low hanging fruit among those problem and work on modeling it. As I�m most commonly help- ing with a legacy replacement, we�ll start modeling on white- boards. And modeling is an art, not a science, so it�s not uncom- mon to run into a wall and circle back or even have a revelation that makes you change direc- tion. It�s good for them to expe- rience that with someone who is familiar with modeling and is not worried about the perspective changing while you are going through the process. I do some mob programming with them while I�m there for the same rea- son. I have a good idea of what technical problems we may run into so I can guide them through.
InfoQ: Any final thoughts for people trying to get started with DDD?
Lerman: While many people start their DDD journey by focus- ing on the technical software im- plementation (known as the tac- tical design), the strategic design is vital to DDD and comes first in the process as you work with the domain experts to learn about their domain and plan your sys- tem. Be sure to have at least a general understanding of the breadth of DDD, its goals, where it is useful and where it is overkill before diving in.
 8 DDD in Practice // eMag Issue 65 - Oct 2018

  I�m drawn to the human side of the DDD equation � that whole aspect of working closely with your clients to understand their business, identify their problems and gain their trust in you to help solve those problems.
  DDD in Practice // eMag Issue 65 - Oct 2018 9

  Read online on InfoQ
The DDD Do-Over
Q&A with Jimmy Bogard
by Thomas Betts
At the 2017 Explore DDD conference, Jimmy Bogard spoke about a rare opportunity to have what he considered a �do-over� on a project. While not a complete, start-from-scratch rewrite, he worked on two very similar projects, for related companies. InfoQ met with Jimmy to discuss how the lessons learned from the first project were applied to make the second more successful.
 KEY TAKEAWAYS
Two separate projects within similar domains, both implemented using DDD, provided an interesting opportunity to learn from missteps and do better.
Bounded contexts weren�t used on the first project because it would have required the client to buy into building smaller systems.
The biggest difference between the two projects was embracing bounded contexts and creating anti- corruption layers.
Ubiquitous language is limited to within a bounded context. While some terms can be used throughout a wide domain, the definitions can be vastly different.
  10 DDD in Practice // eMag Issue 65 - Oct 2018

THE PANELIST
 Jimmy Bogard
is chief architect at Headspring, author of the MVC in Action books, an international speaker and prolific OSS developer.
He is an expert in distributed systems, REST, messaging, domain-driven design and CQRS.
  The second system was a bit more constrained - providing a single system solely for county prosecution departments for the state of Texas, and only for the adult process.
InfoQ: When the first project was started in 2007, DDD was still a fairly new idea. What was the experience level among your team, and at the client, with DDD concepts, such as domain modeling, ubiquitous language, and bounded contexts?
Projects are marathons, not sprints. Approach them with more of a product thinking, instead of project, designing for the long term.
                      InfoQ: �If we could do ev- erything over again...� is a common refrain for anyone who has worked on a large software project. That wisdom of hindsight usually helps guide future projects. You
had the rare opportunity to actually work on two projects, a few years apart, with almost the same client and domain. What can you tell us about the clients, the projects, and the major objectives?
Jimmy Bogard: The ultimate end users were Texas state em- ployees, spanning many differ- ent geographic boundaries. The first system is a case manage- ment system for juveniles, cov- ering every aspect of the legal process. The overall goal of the juvenile system isn�t to punish, but to provide help for kids that run afoul of the law. The clients included counties for the major metropolitan areas of the state, as well as a state agency charged with oversight of each county program.
Bogard: The tech lead (myself) and the architect had a few years of experience building systems DDD-style. My first DDD project was in 2005, where I also intro- duced XP and Scrum to a prod- uct team. We did not have as much experience with bounded contexts, though the community at the time was much more fo- cused on the structural patterns.
InfoQ: Do you think that level of experience led to any major missteps along the way? For example, did the software have unnecessary complexity due to the design and devel- opment practices that were followed?
Bogard: No, not really. It took a few projects to iterate over de- sign concepts that morphed into what we did today. The biggest mistake - no bounded contexts - would have required the cli- ents to buy in to building small- er systems. That was not going to happen. Otherwise, we were very careful to build only what we needed and design to the assumptions that we knew. Be- cause the scope was so large, we knew that we couldn�t gold plate if we had any hope of finishing,
 DDD in Practice // eMag Issue 65 - Oct 2018 11

so we were diligent about push- ing back on complex require- ments.
InfoQ: The system was built and paid for by one agency, but had to meet the needs of various other groups. Did this lead to any compromises in the design of the domain model? Was the language used truly ubiqui- tous?
Bogard: Absolutely this led to compromises in the design. Sometimes our design was a bit naive, and once we learned the full domain in an area, we�d see its design would be fundamen- tally incompatible with the rest of the system. So, we had to com- promise. Regarding language, we found that while the terms were ubiquitous, the meanings behind them could be different. This would only surface once we�d get various domain experts in the room, and we�d discover that coming in, everyone thought they agreed, but at the end of a meet- ing, no one did.
InfoQ: On your second project, what were some major differenc- es about the approach, specifical- ly from a DDD perspective? How were these differences reflected in real life situations?
Bogard: The biggest difference was embracing bounded con- texts. We built anti-corruption lay- ers between our system and oth- ers, so that when another agency interfaced with us, the terms and design were familiar to them but we�d translate internally. For ex- ample, both law enforcement and prosecutors have a concept of an �offense�. In our actual system, we partitioned the two concepts so that there were two �offense� domain objects - one for law en- forcement, and one for us. Keep- ing them separate meant that we
could grow each independently of the other.
InfoQ: Unlike your first project, which rigidly followed pat- terns, your second project took a far more pragmatic approach. What are some recommenda- tions you have for getting a project completed, while still achieving high-quality, main- tainable code that meets the customer�s needs?
Bogard: That projects are mara- thons, not sprints. Approach with more of a product thinking, in- stead of project, designing for the long term, but around only the verified assumptions we�ve made. If we make new discoveries, then we build plans to incorporate those changes instead of letting our design rot over time.
InfoQ: Do you have any recom- mendations for readers looking for more of the design advice that you followed?
Bogard: SOLID in Slices not Lay- ers
  12 DDD in Practice // eMag Issue 65 - Oct 2018

  Getting Started With Domain Driven Design � Top 3 Concepts
Why Domain-Driven Design?
Enterprise applications hold the promise of meet- ing critical business objectives and delivering real value for users. But these benefits are often diluted by the complexity and costs that come with devel- oping them. Enterprise applications are notoriously hard to develop and difficult to evolve as business needs change, and in the end the costs of develop- ing your own enterprise applications often outweigh the real-world benefits they achieve. As a result, many enterprises turn to off-the-shelf, cookie-cutter appli- cations that, by definition, deliver little to no compet- itive advantage.
With the emergence of the digital economy, off-the- shelf apps just won�t cut it. Enterprises in all industries are under pressure to use software and applications to deliver new, differentiating digital services to cus- tomers. How do you differentiate from the competi- tion if you�re using the same applications? The answer is: you can�t. Every enterprise needs to embrace mod- ern software and application development as a core competency.
In light of this, what steps can architects and develop- ers take to maximize the upside of developing their own enterprise applications while mitigating the downside? Traditional approaches no longer work because they result in exorbitant complexity and costs related to rework, increased risk, and project failure. Fortunately, there is an answer, and it lies with adopting modern design patterns like Domain-Driv- en Design (DDD).
Domain-Driven Design�Key Concepts
The old adage �measure twice, cut once� is particu- larly relevant here. DDD puts the focus on designing software that closely aligns with your business pro- cesses and evolves with changing business needs. It does this by focusing complex application designs on the core business domain being automated. As such, it engages business domain experts up front to itera-
tively refine a conceptual model that addresses prob- lems related to their business domains.
Thought leaders and subject matter experts have written extensively about DDD, so in this post I would like to cover the most essential concepts�just enough to give you a good footing in these concepts and to prepare you for delving into the next level of detail. The concepts that follow are nowhere near comprehensive with respect to DDD, but these con- cepts are indispensable to DDD�a required part of your basic knowledge as you peel back the layers.
What Is A Domain?
A domain is a sphere of knowledge, influence or ac- tivity. It is the business area of focus for the applica- tion developer. The underlying premise of DDD is that the complexity is in the domain, not in the technolo- gy. Frameworks and tools have removed complexity from technology and the big payoff resides in a deep- er understanding of the core business domain, which gets to the heart of what is really important and the reason you�re writing the application in the first place. By distilling the core domain, you can focus your re- sources on areas that are most directly related to the problem you are trying to solve with the new appli- cation.
The core domain may be supplemented with sup- porting domains or generic subdomains. Your energy should be directed at the core domain; while support- ing and generic domains are often necessary, these are not where you will differentiate your application, so you may opt for buying off-the-shelf capabilities, using existing libraries or outsourcing these less dif- ferentiated areas to other vendors. For example, your application may not be focused on financial capabili- ties, but may require some aspects of it.
Click here to read the full article
Sponsored article
  DDD in Practice // eMag Issue 65 - Oct 2018 13

                              Read online on InfoQ
VIRTUAL PANEL
SUCCEEDING WITH EVENT SOURCING
by Richard Seroter
The idea of Event Sourcing has
been around for a while. But recently, we�ve seen more real-world examples of this data storage and retrieval pattern. When should you use this approach? What are the architectural implications? Where do you depend on a platform versus an application framework?
 KEY TAKEAWAYS
Event Sourcing works a bit like a ledger. Every event related to a �thing� (aka an �Aggregate�) is recorded in a persistent journal (aka an Event Store). Whenever you need to know the current state of the thing, it can be recreated by �re-applying� all the events for the thing to the thing.
It�s important to respect the boundaries of our bounded- contexts and recognise that it�s important that we manage the borders between our domains very carefully in our code. This means avoiding cross-domain dependencies on specific events.
Should developers custom build core parts of a CQRS and Event Sourcing framework? No.
  14 DDD in Practice // eMag Issue 65 - Oct 2018

THE PANELISTS
     Ben Wilcock
is a Senior Solutions Architect for Pivotal Labs and helps Pivotal�s Fortune 500 clients to go cloud- native using the Pivotal Application Service (PAS) and Pivotal Container Service (PKS). Ben has a passion for CQRS, event sourcing, microservices, cloud, and mobile applications. He�s also an established technology blogger whose articles have featured in DZone, Java Code Geeks, InfoQ, The Spring Blog and more. You can follow him on Twitter (@benbravo73) and read his blog.
Allard Buijze
is Founder and CTO of AxonIQ. Starting
at the age of 6, he has developed a
great passion for programming and has guided both large and small organizations
in building performant and scalable applications. Now, he is on a mission to make implementations of large scale systems easier, using the concepts of Domain Driven Design, Command-Query Responsiblity Segregation and Event Driven Architectures.
InfoQ: How do you explain Event Sourcing, and please give us a real-world example of where this pattern was an improvement over a more traditional architecture.
Buijze: Event Sourcing is a style of storing entities, not by direct- ly storing their state, but rather as a sequence of events (i.e. an event stream) describing all the changes that happened to that entity in the past. The current state of the entity is recalculated by replaying all the past events on an �empty� instance. General- ly, an event stream describes the changes that happened to an ag- gregate: a group of entities that are considered as one unit in re- spect to state changes. For exam- ple, instead of storing the state of an order, and being able to see that a specific item was ordered, and that the order was cancelled, with Event Sourcing, you would store the fact that the order was
created, several items were add- ed, some items were removed, the order was confirmed, then shipped, and then cancelled. The Event Stream contains a lot of in- formation that may be valuable, but would have been lost if just storing the state.
Event Sourcing has a lot of advan- tages (and some disadvantages as well!). It provides, for exam- ple, a reliable audit trail of what happened to a component in the past. That is because it doesn�t store this �trail� as a side-effect, but it�s the only thing that the current state is based on. Any de- cision that has been made can be explained by the past events.
In one of the projects I was in- volved in, we used Event Sourc- ing to allow for this audit trail to be �native� to the application. We knew the information was also going to be useful for analytics, but simply didn�t know how, yet.
The application was an online card-game (called Bridge) that al- lowed users to play tournaments and win real money prizes. Some- what similar to how poker tour- naments work. As large money prizes were involved, auditing was important.
Not too far into the project, we noticed we didn�t like the domain model we used in the �game en- gine�, the component that imple- mented the rules of the Game. Because we used event sourcing, all of our tests were in the style of �given past events, when execut- ing this command, expect these new events to be published�. Both commands and events we driven by functional require- ments, rather than technical ones. This meant we could leave the tests as they were, and freely re-implement the �game engine�.
Some time later, with the system actively used in production, the
 DDD in Practice // eMag Issue 65 - Oct 2018 15
 
audit trail has proven it�s use: a number of complaints came in of users playing �suspicious moves�. The lead developer decided to build some analytics tooling to investigate the situation. By re- playing past events and creating different view models based on them, he managed to uncover a network of colluding players, that increased their chances of winning. They managed to seize a significant amount of money from their accounts, before it was paid out.
Had only the current state been stored, there was a big chance the information needed to un- cover this fraudulent activity was lost as well.
Wilcock: When I�m with a client, I try to explain event sourcing in a way that resonates with them and reflects the domains that they recognise. So if I�m with a retailer, for example, I might use �Product Catalogue Manage- ment� as an example. Tradition- ally if a developer were asked to develop a solution for such a domain, they�d probably be- gin with a design that relies on CRUD based persistence rather than Event Sourcing. However, very quickly, as the true nature of the domain is discovered, it soon becomes clear that being limited to single row record for each product isn�t enough. In real life, Products get added to Catalogues via a complex life- cycle that is full of key decision points (events) that need to be carefully tracked for all kinds of reasons - regulatory & competi- tion compliance reasons, safety reasons, profitability reasons, supply-chain integrity reasons, operational reasons, and many other things all affect the jour- ney of a product into the cata- logue and the products lifecycle while it�s there.
When we try to deal with these complex requirements using a purely CRUD based model, very quickly we need to start adding �Audit Tables�, �Notifications�, �Relationships� and �Rollbacks� and �Reports�, and all this adds a great deal of complexity to our CRUD models. What initial- ly seemed the �simplest thing that could work�, soon becomes quite complex and not a particu- larly neat or elegant solution. By starting with CRUD we may soon �paint ourselves into a corner�.
For this reason, I try to introduce clients to Event sourcing very early in the design process. Event Sourcing is fundamentally differ- ent. It�s driven and shaped by the true nature of complex domains like the one I�ve described above. Event Sourcing treats domain events as first-class citizens of the solution design (rather than as an afterthought as is often the case with CRUD). For those new to the concept, Event Sourcing works a bit like a ledger (one of the oldest and most successful record keeping systems we�ve ever known). Every event related to a �thing� (aka an �Aggregate�) is recorded in a persistent jour- nal (aka an Event Store). When- ever you need to know the cur- rent state of the thing, it can be recreated by �re-applying� all the events for the thing to the thing. So for example, if we were track- ing the RRP of a Product, we�d use PriceChanged to do this and those events may show that the product was initially $199 set by Bob, then dropped to $149 set by Jill and is currently $109 set by Jane. The �Event Store� would hold all these events for this product, and the Product�s cur- rent price could be ascertained at any time by re-applying it�s PriceChanged.
The beauty of this method is that there is no need for a sep-
arate audit or price history table. We know Bob, Jill and Jane all changed the products price at some point in the past because we stored all these events and �sourced� the current Product from them. We can also go �back in time� and show historic prices very easily. And finally, we can retrospectively add meaningful full history reporting, such as �who is top price changer since time began�, �which quarter has most price volatility�, and other business insights. Because we have every event ever record- ed, we can do a lot of really neat things, we can build a new ver- sion of the system and see how it behaves with our real-life event records before we go into pro- duction!
It�s true that Event Sourcing can have a learning curve associated with it initially, but once the true complexities of an enterprise scale domain are taken into ac- count, it�s usually the more ele- gant solution architecture.
InfoQ: How should we think about cross-domain inter- actions in an Event Sourcing world? In Ben�s example, do we need to maintain a con- sistency expectation across Aggregate boundaries of Pri- ceEvents and another �thing�? How does this play out in long-running Sagas?
Wilcock: I think I interpret this more generally as a Domain Driven Design question rather than purely as an Event Sourc- ing question. As such, I would recommend that readers seek out the DDD Distilled and Imple- menting DDD by Vaughn Vernon (@VaughnVernon) for some ter- rific insights on this topic.
On the specific topic of how to think about cross-domain inter-
 16 DDD in Practice // eMag Issue 65 - Oct 2018

actions, I think it�s important to respect the boundaries of our bounded-contexts and recog- nise that it�s important that we manage the borders between our domains very carefully in our code. What we probably want to avoid is introducing cross-domain dependencies on specific events (like the Price- Changed event). If we do that (i.e. share the class definitions or formats for our events across bounded contexts), we diminish our ability to write code inde- pendently and introduce phys- ical bindings into the code that were unintentional.
This, of course, affects how we think about consistency, but I think that anyone who buys into the idea of DDD and mi- croservices probably already ac- cepts the fact that cross-domain consistency is difficult and is probably accepting of eventual consistency and loose coupling instead. It is for this reason that patterns like Anti Corruption Layer are a common feature of DDD architectures.
Buijze: In essence, the concept of Event Sourcing itself does not ever cross boundaries. While ex- act definitions �out there� differ, my take is that Event Sourcing is a choice for persisting the state of an object as a series of events, rather than state. How an object is persisted, it a choice that should never leak beyond a component, let alone among contexts.
However, in practice, the events that describe changes to an ob- ject are often also very useful for other components, and they get used to synchronize different models. Either in the same con- text, for example to update view models when applying CQRS, or in different contexts.
As Ben pointed out, in the lat- ter case, extra precaution is re- quired to make sure not to get unwanted coupling between the contexts. One things that you want to avoid, is simply pub- lish all events out for any compo- nent to use. Let�s illustrate with an example: a Shipping module is interested in knowing when an order has been placed. But the Order module doesn�t emit exactly that event (Orders are much more tricky than that). Instead, it emits OrderCreated, ItemAdded, ItemRemoved, Pay- mentInformationRegistered and OrderConfirmed. The Shipping module would need to listen to all of these events to be able to get the information it requires to do its work. Worse than listening to all the events, it is also repli- cating much of the �logic� as- sociated with processing these events, such as how to match an ItemRemoved against an ItemAdded.
This is where events should be treated with care when used cross-context. We generally rec- ommend our customers to only share events between compo- nents within the same context.
To synchronize components between context, you want more coarse-grained events de- scribing what happened. One solution would be to send out a different event, such as Order- Placed containing relevant order details, when the order was con- firmed. The other is to consid- er the OrderConfirmed event a so-called �milestone� event, and make it contain more relevant data, so that it still carries value outside of the Order context.
Both solutions have advantages and disadvantages, and are con- sidered part of Strategic Design in DDD.
Sagas are �just a component� in this sense. They an live within a context, dealing with low-level, order related details, for exam- ple, or live in between contexts, coordinating some higher-level process, such as making sure an invoice is created when an order is placed and that a shipment is planned. They help reduce the direct coupling of contexts, so that shipping doesn�t need to know exactly �when� to create a shipment. A Saga could coordi- nate that instead.
  DDD in Practice // eMag Issue 65 - Oct 2018 17

InfoQ: In Event Sourcing, what�s the role of an appli- cation framework versus platform component? That is, in an ES/CQRS architecture, what should we expect from our event stream processor or database, versus a Java frame- work like Axon? Additionally, should developers custom build any core parts of this architecture?
Wilcock: I�ll let Allard comment on Frameworks, Stream Pro- cessing and Event Stores com- parisons. But on the question, of whether developers should custom build the core parts of the framework, my answer would be a firm no; not if they have any choice.
This exact question has come up several times for me recent- ly and my answer is always the same - don�t do it. Designing, testing and delivering a safe, pro- duction-grade CQRS and Event Sourcing architecture is quite dif- ficult (I�m sure Allard can back me up on this) and it�s easy to make mistakes. That�s not to say it can�t be done, it can, but that doesn�t change the fact that it�s �undiffer- entiated heavy lifting�.
Building your own CQRS/ES ar- chitecture in 2018 is definitely �below the value line� - it doesn�t add any value to a regular Bank, Retailer, Manufacturer, Service Provider etc. Asking developers to work on a DIY solution may be technically interesting, but it�s a complex exercise that will take time, brains and cash away from the things that really matter like attracting new customers or in- creasing profitability.
For me, a much more sensible approach is to seek out a reputa- ble open-source alternative and start with that. There are plen- ty of credible options out there to choose from: For Java devel- opers, the Axon Framework is
a particularly good option. It�s mature, stable, extensible, works well with Spring Boot and has some great reference customers in a variety of industries. Devel- opers on .NET have many viable options (such as Brighter) as do those using Node (Wolkenkit) and users of several other pro- gramming languages. I�d inves- tigate such alternatives first and start there. Because it�s open- source you can always fork it later if you really must.
Buijze: Obviously, being the author of Axon Framework, I�m completely biased on this one, but I completely agree with Ben. I�d like to add that the rea- son AxonFramework exists, is because I started implementing an application using CQRS and Event Sourcing, and noticed a large amount of �plumbing� was required. I started sharing the common parts of the code and people started re-using that. This was early 2010. Building your own would mean you�re ignoring 8 years of experience.
The way I position Axon Frame- work nowadays, is as a framework that helps separate the business logic from the infrastructure log- ic, allowing developers to imple- ment the business logic using DDD principles, and providing the (common) infrastructure el- ements out of the box. Compo- nents need to interact, obviously. We have identified 3 reasons for this interaction, each with their own message type: commands - the system must do something (i.e. change state), events - a no- tification that something hap- pened and queries - a request for information. Each of these mes- sages have very distinct routing patterns.
When using proper abstractions, a component doesn�t need to know about the exact infrastruc- ture components being used to
transport these messages. Even, it shouldn�t even matter if the components are deployed as part of a single deployable unit, or in different ones. Infrastruc- ture elements must be select- ed/configured that match the chosen deployment style and non-functional requirements. This is where the choice for event stream processors come in. It is an application framework�s role to make sure these processors can be accessed using proper abstractions, so that the business logic is not tied to implementa- tion specific choices.
At AxonIQ, we have noticed that most databases (especially the relational ones) are a reasonable fit to serve as an Event Store. But performance is impacted when the size of data in the database grows. While we have a natural tendency to think that NoSQL is the solution, it appears they are less optimal than the good old DBMS actually. It is important to realize what choices a data- base (especially the NoSQL im- plementations) has made. These choices often conflict with the expectations of an Event Store implementation. That�s why we have recently released AxonDB, a database that is optimized for storing large amounts of events for the purpose of Event Sourc- ing.
To the question of whether de- velopers should build their own core parts, I�d say no. Unfortu- nately, every now and then, we have to come to the conclusion that no suitable part exist yet that match our non-functionals.
InfoQ: What advice do you have for teams trying to do Event Sourcing in a large or- ganization with many teams? Where are the pitfalls? What
 18 DDD in Practice // eMag Issue 65 - Oct 2018

should, and shouldn�t, be shared?
Buijze: My recommendation would be to make two clearly distinct choices. One is whether to choose an event-driven archi- tecture at all, the other is wheth- er or not to apply event sourcing. While both techniques empower eachother, there is no strict de- pendency of one on the other.
Whether to use Events as a pri- mary element in the communica- tion between components is an architectural decision. It should be embraced by all (or at least most) components for it to hold true value. I believe the answers to the questions before have al- ready shown that using events is a very powerful approach when building complex systems.
Whether to use Event Sourcing, is a decision that needs to be made by each component. There can be directives or guidelines on the architectural level about when to and when not to, but it�s a local decision. It is still possible to emit events, while not using those events internally as the sole source of state. You will still ben- efit from the ability to see what has happened (by storing the published events) and to asyn- chronously inform other com- ponents. It�s just less reliable as an audit trail, as there is no guar- antee that the state and history match. It�s like putting a little led- ger next to Kenny�s grafitti wall that all artists that overwrite pre- vious work will have to sign off. The idea is nice, but there�s a big chance, at some point, there will be some entries missing. Having no audit trail is probably better than having one that proves you wrong....
I also urge anyone working on large scale (distributed) systems, and especially when using Event Driven Architecture, to read up on Domain Driven Design. In
particular the part about Bound- ed Contexts contains some very good guidelines for making choices on where to put certain logic and how to design the in- teraction between components. Carefully choose the directions of dependencies. Events are a good way to invert a dependen- cy, but let�s not forget that we have Commands and Queries as well.
As a last remark: I am glad to see that Events are given a more dominant position in modern ar- chitectures. We must be careful not to over-react and see events everywhere (beware hammers & nails). Let�s not forget about the Commands and Queries and start giving them the same amount of attention.
Wilcock: I�d probably start by saying that Event Sourcing in iso- lation is definitely useful, but it�s power and potential is amplified when it�s used to complement a CQRS architecture and Domain Driven Design. One of the pit- falls of using Event Sourcing in isolation is that it can be viewed simply an alternative persistence mechanism, but this undermines it�s wider potential - it�s ability (with CQRS and DDD) to put dis- tributed event-driven architec- ture at the centre of an elegant and scalable solution architec- ture. Similarly, having events simply �appear� without having some traceability or �cause and effect� back to the commands that brought them into existence also seems like a lost opportu- nity. Having commands spawn events is a really elegant solution to many systems problems (far more elegant than traditional CRUD approaches in my book).
In a large organisation, another potential pitfall is that of com- monality or standardisation between teams. Having many teams, each with their own �do
it yourself� approach to Event Sourcing could result in a sig- nificant waste of time, money & brains and cause non-trivi- al maintenance headaches for years to come. It�s much better, in my opinion, to start with a common framework as a base- line and only deviate from this framework with strong justifica- tion. CQRS and Event Sourcing is a solved problem. Don�t reinvent the wheel, and don�t have 10 teams re-invent the wheel at the same time.
Finally, take great care with what event data you share be- tween teams. Some events can be shared but many can- not, not without introducing inter-team dependencies and couplings that will be hard to decouple in the future. Patterns like �anti-corruption layer� can prove useful in preventing these unintentional couplings, but can also add some complexity and overheads to your work. What- ever you decide, It�s helpful to design events carefully, apply- ing thought to what data should be in an event and what can be left out, and maybe thinking about the event classifications that you can use that identify and separate �internal� events from �external� events. Getting an event-driven solution design right can be a challenge, but the rewards can be great!
 DDD in Practice // eMag Issue 65 - Oct 2018 19

 20
DDD in Practice // eMag Issue 65 - Oct 2018
KEY TAKEAWAYS
There are three levels of refactorings: Code-level, micro refactorings; Refactoring to patterns; and refactoring to a deeper model.
Making many, small changes can lead to compounded, large changes, both in the system itself, and your understanding of it.
The case study discussed here covers camera integration with Nexia Home Automation. The refactoring performed made it easier for developers to understand the domain model and to reason about the Java and Ruby code in the system.
The refactoring reinforced good DDD practices, such as having strong bounded context, and explicitly translating across context boundaries.
REFACTORING TO A DEEPER MODEL
by Paul Rayner | Reviewed by Thomas Betts This article was adapted from a presentation by Paul Rayner, recorded at Explore DDD 2017.
In the world of chemistry, you can take different substances, each of which, on its own, is in a stable state, and then combine them and they react to become something greater than the sum of the reactants. Similarly, in software, there are different refactoring reagents, each with different effort, frequency and potency.
Read online on InfoQ

                                                                       When combined with do- main-driven discovery and ex- ploration process catalysts, these refactoring reagents provide code chemistry reactions that transform code towards a rich domain model.
This is a story of a refactoring within a system that�s been around for a long time, the video camera support in Nexia Home Intelligence. Nexia is a large- scale Ruby on Rails application with a customer base using tens of thousands of video cameras.
I�m going to cover refactoring at three different levels. In Mar- tin Fowler�s Refactoring, he talks about micro refactorings, small changes that are continually being made at the code level to make incremental improve- ments. Good developers invest the time to memorize and build muscle memory for using their refactoring tools, so these micro refactorings become second na- ture.
In Refactoring to Patterns, Josh- ua Kerievsky talks about higher level patterns, such as the Strat- egy Pattern. He also identifies �smells� to watch for, like shotgun surgery, where making one small change requires lots of addition- al changes. These ideas brought me comfort that I didn�t have to get my design exactly right from the beginning, and that I could start developing, and when I encountered one of the smells, I had the tools available to refac- tor, but only after it was neces- sary.
I�ll be covering the third level, refactoring to a deeper model, which Eric Evans introduced to us in Domain-Driven Design. When I first read the book, part three re- ally caught my attention. In it, he talks about a project where the model just wasn�t working, and
they came up with a way of re- factoring the model to introduce new concepts, and it completely transformed the project.
Looking at these three levels, if you can introduce new con- cepts into your model, that�s a far more powerful refactoring. I would contend that you need to get good at the micro refactor- ings and using patterns to fully leverage refactoring to a deeper model.
About Nexia Home Automation
The Nexia Home Automation sys- tem is written in Ruby, and allows you to do a variety of home au- tomation tasks, such as knowing if windows are open or closed, integrating with motion sensors, and connecting to cameras. Dan Sharp and I worked on the cam- era system, and is the scope of the domain I�ll be covering.
The domain of home automation isn�t like other domains, such as banking or insurance. Instead, it�s a highly technical domain, deal- ing with hardware and firmware. This means the customer isn�t the obvious one, the homeowner, since you can�t ask them ques- tions about firmware.
Our goal was to continue to work on new features, while at the same time improving the support for new video cameras. When a new camera came on
the market, it could take weeks or months, with a lot of shotgun surgery, to add support for that camera to Nexia. We hoped to greatly reduce that timeframe.
If you were to walk through the process of adding a camera to your Nexia setup, you�ll start to notice some of the language that is used. For example, instead of add, you enroll a new camera, and then you activate the cam- era. Enrollment is just letting Nexia know that the camera ex- ists, and has to be done before it is able to connect to Nexia.
Architectural Walk- through
Thousands of cameras, installed in customer homes, talk to many Camera Manager components. The Camera Managers are writ- ten in Java, and communication is over HTTP and SSL. As messag- es come into the managers from the cameras, we place those mes- sages into a Redis jobs queue. Those messages are pulled off of the queue by many Portal Work- ers, which run in the background of the Portal. The Portal Workers are written in Ruby. The Nexia application needs to talk back to the cameras, so we queue up those messages on a RabbitMQ message bus, and those messag- es are handled by the Camera managers. Figure 1 shows this very high-level view of the archi- tecture.
          Figure 1: Nexia Architecture
  DDD in Practice // eMag Issue 65 - Oct 2018 21

The application itself is a Rails application, and a partial view of the codebase is shown in Figure 2. If you�re not familiar with Rails development, the models folder is often where everything goes that isn�t a controller, so don�t assume that it implies a rich domain model. I�ve highlight- ed some of the workers I men- tioned, as well as camera files re- lated to automation. An example of automation in Nexia would be having a series of tasks happen at sunset, or dimming the lights at a specified time.
Figure 2: Rails Application Structure
Three Main Challenges
Our first main challenge was the code being very difficult to reason about. The Java camera managers were over-architected. They used a meta-framework, with lots of abstractions, to po- tentially allow it to work with any type of camera that could ever connect into Nexia. In reality, most of the cameras were quite similar, such as the use of SSL and HTTP, and we didn�t need all the extra layers of abstractions.
As just one example of a system- ic problem, Figure 3 shows a por-
Figure 3: Camera Manager handleRequest() Code Sample
   tion of the handleRequest() method. Any DDD practitioner should immediately have ques- tions about the use of language in this code. Line 91 introduces the term Zombie. What�s a Zom- bie? Line 93 says �if not autho- rized,� but the comment on line 94 mentions authentication, which isn�t the same thing. To make matters worse, line 98 de- clares a variable as auth, which could mean either term. While just a small sample, this code shows some of the issues that we encountered throughout the camera manager codebase.
On the Ruby side, the support for cameras in the portal workers grew over time. Because most of this work was done as needed, by various developers (mostly contractors), it became overload- ed with responsibilities, and was not purposefully modeled.
The great thing about Ruby code is that it�s so concise, and you can express a lot of things in a very small number of lines. However, that was not the case in the Cam- eraWorker, which is responsible
for authenticating and closing camera connections. First, at over 130 lines, it would be excessive to show the full method in this article, so Figure 4 shows just a portion of the code. In multiple places, the worker was doing �surgery� and reaching into the camera object to modify state, rather than declaring the desired behavior. We also encountered some unfortunate naming, such as the start_motion call on line 89, which looked like a command to start motion, but we learned it was not.
As with the Java code, this is just a small snippet, but serves as an example of more systemic prob- lems. All of this made it difficult to reason about the code.
The second challenge was that the camera manager was overly coupled to the device manager. To understand this, a bit of the architecture history needed to be understood. The camera man- ager (CM) evolved from a general device manager (DM) that was designed to manage a wide va- riety of device types. This lead to
  22 DDD in Practice // eMag Issue 65 - Oct 2018

 Figure 4: CameraWorker Code Sample
to just say it�s somebody else�s problem, and not deal with it.
The option I like to support is to experiment and see what you can do. I like the story of how the British cycling team won the gold medal at the 2012 Summer Olympics. The team decided to experiment and find lots of ways to make small improvements, and make many of them. Sir Dave Brailsford, head of British cy- cling, said, �It struck me that we should think small, not big, and adopt a philosophy of continu- ous improvement through the aggregation of marginal gains. Forget about perfection; focus on progression, and compound the improvements.� The idea of continuous improvement should sound familiar to anyone who�s worked in an agile software de- velopment process.
Baby Steps
On our project, we tried a bunch of different things, and many of them didn�t work. In March 2014, we took a �baby step.� We real- ized that the domain concept of a camera is actually two different responsibilities. It is a stateful representation of a physical de- vice, also known as an entity. But it also acts as a command han- dler, providing an interface for sending commands and queries to a physical device.
Looking first at the Ruby code, we saw that both responsibilities were in the Camera object. This was a subclass of Device, which had a lot of issues. Since there was no further subclassing, all logic was in one huge, �god� ob- ject for Camera.
Rather than changing the Cam- era, we first decided to add a new domain service. This follows the principle of being open to extension and closed to modifi-
 a shared kernel with the rest of Nexia. This became a significant deployment issue, and basical- ly meant we could not upgrade Java. We eventually learned that this coupling was unnecessary. While a camera is a device, it does not have a lot of similarity with other devices, like a door lock.
The third challenge, which real- ly involves a DDD perspective, was the domain knowledge being in the wrong place. Most of the domain logic was inside the Java camera manager code. This meant adding new features was complex, time consuming, error prone, and hard to test. Also, modifying that code meant touching almost everything with shotgun surgery.
DDD Concerns
I�ve laid out all these issues not to simply complain about bad code, but to identify that these are not insurmountable challenges. Fur- thermore, DDD provides tech- niques that can greatly improve this situation. That starts with reviewing four main concerns of DDD.
First, we want to grow and ex- press a deep domain model in the code. Number two, we want to refactor the code towards a ubiquitous language where things are consistent and under- stood, and that the intent in the code is clear. Third, we want to clearly delineate the boundaries and responsibilities of the mod- el and modules. It�s very difficult to have high cohesion and loose coupling without clearly defined boundaries. Lastly, we need to enforce model boundaries (aka bounded contexts) and explicitly translate across those boundar- ies.
Where to Start?
What do you do when you en- counter code like this? There are a few options that I know some people have tried, but I don�t see meeting with much success. One option is to �drain the swamp� and try to remove all the old code and just start fresh. Some- times this occurs when someone locks themselves away for a few weeks to just do a major refac- toring, planning to emerge when it�s �fixed.� Option number two is
 DDD in Practice // eMag Issue 65 - Oct 2018 23

cation. This new Camera::Com- mandService became the new home for all camera commands and queries. Because we took the approach of writing this as an extension, we were able to create it using good TDD and pair-pro- gramming practices to create better quality design work with- out breaking anything. We also had the benefit of a good test suite that covered controllers, workers, and other collaborators, allowing us to make updates with a high degree of confidence. This baby step provided a small, but measurable improvement.
Finding a Seam
In his book Working Effective- ly With Legacy Code, Michael Feathers talks about �finding a seam� in your code, someplace where you can insert something new. We did an EventStorming session on the various ways that devices are enrolled in Nexia, and that helped visualize a lot of the similarities in those workflows. Looking at the Java code, we decided that the Camera Man- ager component had too many �smarts.� It should be just man- aging camera sessions, but it was doing so much more. Our idea was to make Camera Manager a generic http proxy, since all com- mands are just HTTP calls, and consolidate all the camera logic on the Ruby side.
The seam we created was in- troducing a new generic send_ url() command on Camera Manager. We focused the http proxy model on connection
Figure 5: Three distinct aspects of authentication
  management,
camera-to-portal
and logging (to aid in trouble- shooting and future metrics). On the Ruby side, we could build on the marginal gains from the year before, and use the Cam- era:CommandService to send arbitrary commands to cameras.
Migrating Domain Logic
With the baby step from a year ago, and this new seam we found, we could begin migrating the camera domain logic from the Java side to the Ruby side. One at a time, we moved Camera::Com- mandService commands (e.g. Pan-Tilt) to use the generic Cam- era Manager interface. What was really cool about this approach was it required no changes to the Java code. As an internal refactor on the Ruby side, we could work on a single command, test it, and iterate until it was working.
When I present this story, one question I hear often is, �How do you justify these kinds of refactor- ings?� I always point out that we were continuing to deliver fea- tures in the application, and this was something we would work on whenever we could. Also, these small steps led to some early wins. Because we provid- ed generic URLs to the cameras and could send commands from Ruby, we could bulk upgrade the firmware on all installed camer- as. Also, the ability to easily and quickly make changes on the Ruby side meant we could con- duct experiments and find other marginal improvements. Previ- ously, this required coordinated changes in both Java and Ruby.
I really want to emphasize the importance of looking for early wins. Non-technical stakeholders don�t care that you refactor the code. I believe, in general, they assume you are a professional, and are doing your best to write maintainable code. That means you have to build up trust and credibility, and finding early wins are one way to do that.
We also found that the refactor- ing led to momentum in clean- ing up the code. In the Camer- a::CameraWorker, there were three distinct aspects of authen- tication. First, authenticate an existing camera upon reconnect. Second, handle the creation and authentication of a new cam- era. The third aspect was to fail a �zombie� camera; one that was connected but not authenticat- ed. By refactoring to a deeper model, the code became much easier to reason about, as shown in lines 8-14 in Figure 5.
As we introduced more domain logic, the Ruby code started to use more of the ubiquitous lan- guage of Nexia. Instead of doing surgery on the camera object and setting lots of properties, we recognized a factory pattern would be more appropriate. The ubiquitous language included
authentication, messaging,
 24 DDD in Practice // eMag Issue 65 - Oct 2018

 Figure 6: New Java code sample (compare to Figure 3)
 the concept of a heartbeat, the concept that the cameras con- nect to Nexia on a regular basis to say that they�re still alive. We then created factory methods named update_from_heart- beat and create_from_heart- beat, to handle existing and new cameras, respectively.
The Java side also benefited from the refactoring. Compare the previous handleRequest() method, which is only partially shown in Figure 3, the five lines in Figure 6. With just a few extract method refactorings the func- tionality became much easier to understand.
The camera class was huge, and that�s something you�ll always run into. A tip for dealing with that situation is to realize that you don�t need to refactor the code to increase your level of clarity. In the presence of overwhelming clutter, simply rearranging code is an easy - but powerful - design technique. Start looking for pat- terns and put similar methods to- gether. This will reduce the cog- nitive load when you�re working on a huge area of code.Refactor- ing to Deeper Insight
Approaching a big, messy code- base can be a lot like walking through a fog � you can�t see everything around you, and may wonder if you�re looking at a bunch of trees, or possibly a mountain. As you make little changes � reorganizing code, extracting methods � those marginal gains start to add up,
and the fog starts to lift. Imple- menting the micro refactorings and patterns that Fowler and Kerievsky talk about creates a cu- mulative effect, which leads to a deeper insight about the model.
For example, on the Ruby side, we realized we were sending commands to the camera. So we followed Kerievsky�s advice and introduced the command pattern. This dramatically sim- plified things. We setup a base class for commands with a stan- dard execute() method. Then we created a camera/command folder and started writing each command, implementing that base class. Along with that, we introduced a feature toggle. This allowed the old code to continue to execute, until the correspond- ing command had been convert- ed. I highly recommend using feature toggles to help you refac- tor safely in this type of situation.
Another approach I recommend is to perform a phased rollout. We wanted to avoid a situation where every camera suddenly disconnected, and most prod- ucts with an existing customer base will probably have a similar desire to not impact the entire audience. In the first month, we deployed only to internal Nexia IP addresses, allowing QA, devel- opers and support personnel to �dog food� the new system be- fore any customer. The second month expanded the deploy- ment to include select custom- ers, but was still only using a sin- gle production server. It wasn�t
Marginal gains accumulate and lead to deeper insight.
           DDD in Practice // eMag Issue 65 - Oct 2018 25

 until the third month that we deployed to all cameras, for all customers, on all production servers. This went much smoother than oth- er production rollouts I�ve been involved in during my career.
Another benefit of feature toggles and phased rollouts is that they create options, and options have value. I recommend the graphic business novel Commitment which covers the concept of Real Options. Usually, when someone in a meeting says, �we have to make a decision,� it seems the only two choices are to either make a decision, with limited knowledge, or to not make a decision. Real options say there�s a third option, to strategically decide to defer the decision until we have better understand- ing. Both feature toggles and phased rollouts allow you to defer some decisions until you can make a more informed decision, and that is key.
Looking Back
Looking back at where we started, there are some big wins that we achieved. Before, add- ing a new camera took weeks or even months. Now, we can add a new camera in a few hours. Instead of having to make changes in both Java and Ruby, and keep the code in sync, we now only need to make changes in Ruby. While the old code was inconsistent in where certain aspects belonged, the new code was far more cohesive, and easier to reason about, within clear contexts. The gnarly dependency between Camera Manager and Device Man- ager was removed, so we no longer were pre- vented from updating Java.
There are a few, general refactoring tips I have, based on this experience. Instead of picking just one idea of how to implement a change, such as naming something new, experiment with at least three language and/or model options. Also, in your day-to-day work, em- brace marginal gains. We tend to dramatically overestimate the power of big changes, and underestimate the power of small, cumulative changes.
 26

  In the presence of overwhelming clutter, simply rearranging code is an easy - but powerful - design technique.
  Testing Your Distributed (Cloud) Systems // eMag Issue 64 - Aug 2018 27

                     Read online on InfoQ
MODELING UNCERTAINTY WITH REACTIVE DDD
by Vaughn Vernon | Reviewed by Thomas Betts Adapted from presentations at Spring One Platform and Explore DDD
Domain-Driven Design is the way I
think software should be developed.
It�s been a bit of an uphill climb from Evan�s original publication of Domain- Driven Design, Tackling Complexity in the Heart of Software, and we�ve come a long way since. Now there are actually conferences on Domain-Driven Design, and I see a lot of growing interest, including business people getting involved, which is really key.
 KEY TAKEAWAYS
Reactive, distributed applications must decide how to handle uncertainty regarding the delivery of messages, including multiple delivery and out-of-order delivery.
Domain-Driven Design can aid with managing uncertainty through the use of good modeling.
Rules for handling uncertainty must be defined in business logic that domain experts have agreed to, not buried in a technical implementation.
The implementation of a message de-duplicator or re-sequencer may initially sound straightforward, but gets unwieldy when operating at real-world scale.
When the rules have been defined using ubiquitous language, the implementation can be very simple and still robust.
  28 DDD in Practice // eMag Issue 65 - Oct 2018

Reactive is a big thing these days, and I�ll explain later why it�s gaining a lot of traction. What I think is really interesting is that the way DDD was used or im- plemented, say back in 2003, is quite different from the way that we use DDD today. If you�ve read my red book, Implementing Domain-Driven Design, you�re probably familiar with the fact that the bounded contexts that I model in the book are separate processes, with separate deploy- ments. Whereas, in Evan�s blue book, bounded contexts were separated logically, but some- times deployed in the same de- ployment unit, perhaps in a web server or an application server. In our modern day use of DDD, I�m seeing more people adopting DDD because it aligns with hav- ing separate deployments, such as in microservices.
One thing to keep clear is that the essence of Domain-Driven Design is really still what it always was -- It�s modeling a ubiquitous language in a bounded context. So, what is a bounded context? Basically, the idea behind bound- ed context is to put a clear delin- eation between one model and another model. This delineation and boundary that�s put around a domain model, makes the model that is inside the boundary very explicit with very clear meaning as to the concepts, the elements of the model, and the way that the team, including domain ex- perts, think about the model.
You�ll find a ubiquitous language that is spoken by the team and that is modeled in software by the team. In scenarios and dis- cussions where somebody says, for example, �product,� they know in that context exactly what product means. In another context, product can have a dif- ferent meaning, one that was de- fined by another team. The prod-
Figure 1 - Context Mapping
uct may share identities across bounded contexts, but, generally speaking, the product in anoth- er context has at least a slightly different meaning, and possibly even a vastly different meaning.
We�re making an effort with DDD to recognize that there is no practical way to have a canoni- cal, enterprise data model where every single element in the mod- el is representative of how every team in the enterprise would want to use it. It just doesn�t hap- pen. There�s always some differ- ence, and many times there are many differences that make it very painful for one team to try to use the model that another team has created. That�s why we�re fo- cused on the bounded context with a ubiquitous language.
Once you understand that there is one, very definite definition for an entity, in one team situation, with one ubiquitous language, then you realize that there are other models, developed by other teams. Perhaps even the same team developing this mod- el could be responsible for oth- er models. You have a situation where you have multiple bound-
ed contexts because, naturally, we cannot define every meaning in a single enterprise, or within a single system, for every single concept that we�re going to use.
Given that we have multiple con- texts and multiple languages, we have to collaborate and integrate between them. To do that, we use a technique called context mapping or a tool called a con- text map.
In the simple digram shown in figure 1, the lines between the bounded contexts are contextu- al mappings, and could appro- priately be called a translation. If one of the bounded contexts speaks one language, and a con- nected context speaks a different language, what do you need to have between languages so that you can understand one model to another? A translation. Typi- cally, we will try to translate be- tween models to keep each sep- arate model pure and clean.
When creating your context map, don�t confuse yourself or place limits on what the line means. While it can cover the technical integration, style or technique,
   DDD in Practice // eMag Issue 65 - Oct 2018 29

it�s very important to define the team relationship between con- texts. Whether I�m using RPC or REST isn�t important. Who I am integrating with is more import- ant than how I am integrating.
It�s very important to define the team relationship between con- texts. Who I am integrating with is more important than how I am integrating.
There are various context map- ping tools for different types of relationships, including part- nership, customer-supplier, or conformist relationships. In a partnership relationship, one team will know a lot about the model on another team. A cus- tomer-supplier relationship features an anti-corruption lay- er between two very separate models, one upstream and one downstream. We will anti-cor- rupt the upstream model as it�s being consumed by the down- stream model. If the downstream model needs to send something back to the upstream, then it will translate it back to the upstream model so that data can be con- sistently and reliably exchanged, with clear meaning.
The strategic design that I�ve de- scribed so far is really the essence of, and therefore the most im- portant part, of Domain-Driven Design.
In some cases, we will decide to model a particular ubiquitous language in a very careful, even fine-grained way. If you think of strategic design as painting with broad brush strokes, then think of tactical design as using a fine brush to fill in all the details.
General Guidance on DDD Mod- elingBased on my observations of conference presentations that mention DDD, and my time working with teams, I�ve been
able to identify a few little tips to help with modeling. These aren�t meant to call out any specific ac- tions as wrong. Rather, I hope to provide some guidance to nudge you in the right direction.
One thing that we have to re- member about DDD when we�re modeling, especially tactically, is we need help from domain ex- perts -- It shouldn�t just be pro- grammers. We have to limit our use of their time, because the people who play the role of a domain expert on a team will be very busy with other matters re- lating to the business. Therefore, we have to make the experience very rewarding for them.
Another thing we want to do is avoid the anemic domain model. Whenever you see a presenta- tion about a domain model that includes annotations that will automatically create the getters and setters, Equals(), GetH- ashCode(), etc., think seriously about running away from that. If our domain models were only about data, then that might be a perfect solution. However, there are some questions we need to ask. How does the data come about? How do we actually get data into our domain model? Is it being expressed according to the mental model of the busi- ness and any domain expert who�s working with us? Getters and setters do not give you an explicit indication of what the model means -- it�s only moving data around. If you�re thinking in tactical DDD, then you have to think getters and setters are ulti- mately the enemy, because what you really want to model are be- haviors that express the way that the business considers how work should get done.
When modeling, be explicit. For example, say you saw the busi- ness identity of an entity or an
aggregate being called a UUID. There�s nothing wrong with us- ing a UUID as a business identifi- er, but why not wrap that in an ID type that is strongly typed? Con- sider that another bounded con- text that is not using Java may not understand what a UUID is. You will most likely have to gen- erate a UUID ToString(), and then hold that string in another type, or translate that string from the type when you�re sending out events between bounded contexts.
Instead of using BigDecimal directly, why not think about a value object called Money. If you�ve used BigDecimal, you know that identifying the round- ing factor is a common difficulty. If we let BigDecimal slip in all over our model, then how do we round some amount of money? The solution is to use a Money type that standardizes on what the business says should be the rounding specification.
One other little tip is to not worry about what persistence mecha- nism is used, or what messaging mechanism is used. Use what meets your specific service lev- el agreements. Be reasonable about the throughput and per- formance you need, and don�t complicate things. DDD is not really talking about technology so much as it is in need of using technology.
Reactive Systems
I have been seeing, at least in my world, a trend towards reactive systems. Not just reactive with- in a microservice, but building entire systems that are reactive. In DDD, reactive behavior is also happening within the bounded context. Being reactive isn�t en- tirely new, and Eric Evans was far ahead of the industry when he introduced eventing. Using do-
 30 DDD in Practice // eMag Issue 65 - Oct 2018

main events means we have to react to events that happened in the past, and bring our system into harmony.
If you were to visualize all the connections at different layers of a system, you�ll see patterns that repeat themselves. Whether you�re looking at the entire in- ternet, or all the applications at an enterprise level, or individual actors or asynchronous compo- nents within a microservice, ev- ery layer has a lot of connections and associated complexity. That gives us a lot of very interesting problems to solve. I want to em- phasize that we shouldn�t solve those problems with technology, but model them. If we are devel- oping microservices in the cloud as a means to form a business, then distributed computing is part of the business that we�re working in. Not that distributed computing makes our business (in some cases, it does), but we are definitely solving problems with distributed computing. Therefore, make the distributed computing aspects explicit by modeling them.
I need to take a minute to ad- dress what some developers use as an argument against asyn- chrony, parallelism, concurren- cy, or any technique that either gives the impression of, or actu- ally facilitates, multiple actions happening at once. Donald Knuth is often quoted as saying, �Premature optimization is the root of all evil.� But that�s just the end of his expression. He really said, �We should forget about small efficiencies... premature optimization is the root of all evil.� Said another way, if we have big bottlenecks in our system, we should address those. We can ad- dress those with reactive.
Donald Knuth also said some- thing else very interesting: �Peo-
Figure 2 - Reactive
ple who are more than casually interested in computers should have at least some idea of what the underlying hardware is like. Otherwise, the programs they write will be pretty weird.� He�s simply saying we need to take advantage of the hardware we have today by how we write our software.
If we go back to 1973 and look at the way processors were being manufactured, there were very few transistors, and the clock speed was below 1MHz. Moore�s Law said we�d see the doubling of transistors and processor speed every couple of years. And yet, when we reached 2011, the clock speeds started to fall off. Today, what used to take a year and a half or two years to double clock speed, is now taking about ten years, if not longer. The num- ber of transistors is continuing to increase, but the clock speeds aren�t. Today, what we have are cores. Instead of being faster, we have more cores. So what do we do with all these cores?
If you�ve been keeping up with Spring and the Reactor project, which uses reactive streams, this
is essentially what we�re able to do now. We have a publisher, and a publisher is publishing some- thing, let�s call them domain events, the little orange boxes in Figure 2. These events are being delivered to each of the subscrib- ers on the stream.
Notice the lilac boxes on the stream that have question marks on them. That is actually a policy. And that policy is between the stream and the subscriber. For example, a subscriber may have a limit on how many events or messages it can handle, and the policy specifies the limit for any given subscriber. What�s import- ant is that separate threads are being used to run the publish- er, the stream, and all three of the subscribers. If this is an in- telligently implemented, large, complex component, then the threads are not being blocked at any point in time. Because if the threads are being blocked, then some other piece of the puzzle is starving for a thread. We have to make sure that the implementa- tion underneath is also making good use of threads. This will be- come more important as we dive
   DDD in Practice // eMag Issue 65 - Oct 2018 31

 Figure 3 - Reactive Systems
deeper into modeling uncertain- ty.
Within a microservice, we are re- active. But, when we look inside, there are all kinds of components that could be running concur- rently, or in parallel. When an event is published inside one of those microservices, it�s ultimate- ly being published outside the bounded context to some sort of topic, possibly using Kafka. To keep it simple, let�s say there�s just one topic. All the other microser- vices in our reactive system are consuming the events published on the topic, and they�re reac- tively doing something inside their microservice. (Figure 3)
Ultimately, this is where we want to be. When everything is happening asynchronously ev- erywhere, what happens? That brings us to uncertainty.
Welcome Uncertainty
In an ideal situation, when we publish a series of events, we want those events to be deliv- ered sequentially, and exactly once. Each subscriber will receive Event 1, followed by Event 2, fol-
lowed by Event 3, and each event appears once and only once. Programmers have been taught to jealously guard this scenario because it makes us feel certain about what we are doing. And yet, in distributed computing, it just doesn�t happen.
With microservices and reac- tive comes uncertainty, starting with uncertainty about what or- der events might be delivered in, and if an event has been re- ceived more than once, or not at all. Even if you�re using a messag- ing system like Kafka, if you think you�re going to consume them in sequential order, you�re fooling yourself. If there is any possibil- ity of any message being out of order, you have to plan for all of them being out of order.
If there is any possibility of any message being out of order, you have to plan for all of them being out of order.
I found a succinct definition for uncertainty: The state of being uncertain. Uncertainty being a state means we can deal with it, because we have ways of reason- ing about the state of a system.
Ultimately, we want to be in a state where we�re certain and can feel comfortable, even if that only lasts a millisecond. Uncer- tainty creeps up and it makes things unpredictable, unreliable, and risky. Uncertainty is uncom- fortable.
Addiction
Most developers learned the �right way� to develop software that leads down a path of addic- tion. When you have two compo- nents that need to communicate with each other, it�s helpful to refer to one as the client and the other as the server. That doesn�t mean it has to be a remote cli- ent. The client is going to invoke a method, or call a function, on the server. While that invocation occurs, the client is just sitting there, waiting to receive a re- sponse from the server, or possi- bly an exception will be thrown. In any case, the client is certain that it will get control again. That certainty of execution flow is one type of addiction we have to deal with.
The second type of common addiction is an addiction to the ordering of things, with no du- plicates. This is taught to us in school at a young age, when we learn to count, in order. It makes us feel good when we know the order in which things happened.
Another addiction is the locking database. If I have three nodes in my data source, when I write to one of those nodes, I believe I have a firm lock on the database. Which means that when I get back a success response, I believe that the data is persisted on all three nodes. But then you start using Cassandra, which doesn�t lock all the nodes, how do you query for a value that hasn�t propagated across the cluster, yet?
  32 DDD in Practice // eMag Issue 65 - Oct 2018

All of these things create an un- comfortable feeling in us, and we have to learn to deal with that. And yet, it�s okay to feel uncom- fortable.
Defense Mechanisms
Because we�re addicted to cer- tainty, blocking, and synchroni- zation, developers tend to deal with the uncertainty by building a fortress. If you�re creating a mi- croservice that is modeled as a bounded context, you design it so that everything within that context is blocking, synchro- nized, and non-duplicate. That�s where we build our fortress, so all the uncertainty exists outside our context, and we get to devel- op with certainty.
Starting at the infrastructure lay- er, we create a de-duplicator and a re-sequencer. These both come from Enterprise Integration Pat- terns.
De-Duplicator
If events 1, 2, 1, and 3 come in, when they pass through the de-duplicator, we�re certain that we only have events 1, 2, and 3. That doesn�t seem too difficult a problem to solve, but think about the implementation. We�ll proba- bly have some caching enabled, but we can�t store infinite events in memory. This means having some database table to store the event ID, to allow checking every incoming event to know if it�s been seen before.
If an event hasn�t been seen be- fore, pass it along. If it has been seen it before, then it can be ignored, right? Well, why has it been seen before? Is it because we didn�t acknowledge receiving it? If so, should we acknowledge that we�ve received it again? How long do we keep those IDs around to say we�ve seen the
event? Is a week enough? How about a month?
Talk about uncertainty. Trying to solve this by throwing technolo- gy at it can be very difficult.
Re-Sequencer
For an example of re-sequenc- ing, imagine we see event 3, then event 1, then event 4. For what- ever reason, event 2 just hangs out for a really long time. We first have to find a way to re-order events 1, 3, and 4. If event 2 hasn�t arrived, have we effectively shut down our system? We may allow event 1 through, but we could have some rule that says to not process event 1 until event 2 ar- rives. Once event 2 arrives, then we can safely let all four events into the application.
With any implementation you choose, all of these things are hard. There is uncertainty.
The worst part is we haven�t solved any business problems, yet. We�re just solving technolo- gy problems. But, if we acknowl- edge that distributed computing is part of our business now, then we can solve these problems in the model.
We want to say, �Stop everything. Okay, I�m ready now.� But there is no �now.� If you think your busi- ness model is consistent, it may only be consistent for a nanosec- ond, and then it�s inconsistent again.
A good example of this is a Java call to LocalTime.now(), which is simply not true. As soon as you call into it, it�s no longer now. When you get a response back, it�s no longer now.
Uncertainty of Distributed Systems
This all brings us back to the fact that distributed systems are all about uncertainty. And distribut- ed systems are here to stay. If you don�t like it, change careers. May- be open a restaurant. However, you�ll still be dealing with distrib- uted systems, you just won�t be writing them.
Modeling uncertainty matters. It matters because multiple cores are here to stay. It matters be- cause the cloud is here to stay.
Microservices matter, because it�s the way everyone is going. Most people approach me about learning Domain-Driven Design because they see it as a great way to implement microservices. I agree with that. Also, people and companies want out of the monolith. They�re stuck in the mud, and it takes months to get a release out.
Latency matters. When you have a network as part of your distrib- uted system, latency matters.
IoT matters. Lots of little, cheap devices, all talking over the net- work.
DDD and Modeling
What I refer to as Good Design, Bad Design, and Effective Design.
You can completely design soft- ware well, and yet miss what the business needs. Take SOLID, for example. You can design 100 classes to be SOLID, and com- pletely miss what the business wants. Alan Kay, the inventor of OO and Smalltalk, said the really important thing about objects was the messages sent between them.
Ma, a Japanese word that means �the space between.� In this case,
 DDD in Practice // eMag Issue 65 - Oct 2018 33

 Figure 4 - Activity
the space between the objects. The objects need to be designed well enough so they are able to play their single, responsible role. But it�s not just about the insides of the objects. We need to care about the names of the objects and the messages that we send between them. That is where the expressiveness of the ubiquitous language comes in. If you are able to capture that in your mod- el, that is what makes your model effective, not just good, because you will be meeting the needs of the business. That is what Do- main-Driven Design is about.
We want to develop reactive sys- tems. We�re going to deal with the fact that uncertainty is a state. We�re going to start solving some problems.
In his paper, Life Beyond Distrib- uted Transactions, an Apostate�s Opinion, Pat Helland wrote, �In a system that cannot count on dis- tributed transactions, the man- agement of uncertainty must be implemented in the business logic.� This realization came after a long history of implementing distributed transactions. Howev- er, while working at Amazon, he
determined that the scale they needed could not be achieved by using distributed transactions.
In the paper, Helland talks about activities. An activity between two partner entities occurs when one entity has a state change and raises an event describing that change, and the second en- tity eventually, hopefully, it re- ceives that message. But when will it receive the message? What if it is never received? There are a lot of �what ifs� and Pat Helland
says these �what if� should be handled by activities.
Between any two partners, each partner has to manage the ac- tivity that it has seen from its partner to itself. Figure 4 is how I interpret what Pat Helland meant by these.
Every partner has a PartnerAc- tivities object that represents the activities of one related en- tity we receive activities from. When we see some activity di- rected toward us, we can record that. Then, at some future time, I can ask, �have I seen this partner activity?� This handles both the case where I�m dependent on that activity having occurred, or to check if I�m seeing it again.
This is fairly straightforward, but gets more complicated in a long- lived entity. Even Pat Helland says this can grow enormously. Any given long-lived entity, po- tentially with a lot of partners, can result in collecting huge en- tities, or what DDD would call an Aggregate, just to try and track the activities. Furthermore, this isn�t explicit -- it doesn�t say a thing about the business itself.
  Figure 5 - Process Manager
  34 DDD in Practice // eMag Issue 65 - Oct 2018

 Figure 6 - Handling Duplicate message
 I think we should go further than a PartnerActivity. The tech- nique I�m proposing is to put this in the heart of the software, in the domain model. We eliminate those elements in the infrastruc- ture layer (the de-duplicator and re-sequencer) and we let every- thing through as it happens. I be- lieve this makes the system less complex.
In an explicit model, we listen to events and send commands that correspond to business actions. Our domain aggregates each contain the business logic for how to handle those commands, including how to respond to the uncertainty. The communication of events and commands is han- dled by a Process Manager, as depicted in Figure 5. While the diagram may look complex, it�s actually fairly straightforward to implement, and follows reactive patterns.
Each domain entity is responsi- ble for tracking its state, based on the commands it receives. By following good DDD practices, the state can be safely tracked based on these commands, and using event sourcing to persist the state change events.
Each entity is also responsible for knowing how to handle any potential uncertainty, according to decisions made by domain ex- perts. For example, if a duplicate event is received, the aggregate will know that it has already seen it, and can decide how to re- spond. Figure 6 shows one way to handle this. When a denied- ForPricing() command is re- ceived, we can check the current progress, and if we already have seen a PricingDenied event then we won�t emit a new do- main event, and instead respond indicating that the denial was al- ready seen.
This example is almost under- whelming, but that�s intentional. It shows that treating uncertainty as part of our domain means we can use DDD practices to make it just another aspect of our busi- ness logic. And that really is the point of DDD; to help manage complexity, such as uncertainty, in the heart of our software.
If there is any possibility of any message being out of order, you have to plan for all of them being out of order.
                  DDD in Practice // eMag Issue 65 - Oct 2018 35

PREVIOUS ISSUES
  64
Testing Your Distributed (Cloud) Systems
62
 62
 61
    Testing is an under-appreciated discipline and I wanted to shine a spotlight on the changing nature of testing in a cloud-driven world. We hope you enjoy what we�ve put together here, and find a host of thought-provoking, and actionable, ideas.
Service Meshes: Managing Complex Communication within Cloud Native Applications
This InfoQ eMag aims to help you decide if your or- ganisation would benefit from using a service mesh, and if so, that it also guides you on your service-mesh journey.
Real-World Machine Learning: Case Studies, Techniques and Risks
Machine learning (ML) and deep-learning technolo- gies like Apache Spark, Flink, Microsoft CNTK, Tensor- Flow, and Caffe brought data analytics to the devel- oper community. This eMag focuses on the current landscape of ML technologies and presents several associated real-world case studies.
Gender, Race, Age and Neurodiveristy for Software Developers
This eMag draws together ideas that have been pub- lished on InfoQ over a number of years, presenting a wide range of aspects of diversity and ways that indi- viduals, teams and organisations can create environ- ments where diversity thrives, people are respected and outcomes are more successful.
 